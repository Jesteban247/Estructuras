Estructuras de Datos
Primer Parcial

1. Análisis de código

1.1 Cuenta la cantidad de listas que contienen números múltiplos de cinco.

1.2 O(n), el primer ciclo se repite un número constante de veces, y el segundo ciclo, que está anidado, sí se repite n veces; el tercer ciclo, que es secuencial, también se repite un número constante de veces porque el tamaño del vector siempre va a ser 7.


2. Selección múltiple con única respuesta

2.1 Los libros con títulos que comienzan entre la ’H’ y la ’Z’. Al poner los libros en la pila quedan ubicados con los de la 'A' en el fondo y los de la 'Z' encima. Al empezar a sacar, se hace en orden inverso, desde la 'Z', y al parar con un libro que empieza por 'G', los que están por fuera son los que empiezan por 'H' hasta la 'Z'.

2.2 bidireccional. La lista permite hacer lectura y escritura con su iterador, que también puede moverse hacia adelante y atrás. Lo único que no puede hacer el iterador es acceso aleatorio.

2.3 O(n^2). Al ser bloques secuenciales, sus complejidades se suman, y el análisis O() implica enfocarse en el peor caso. Entre las dos tendencias, la que tiene peor comportamiento es O(n^2), por eso corresponde a la complejidad del algoritmo completo.


3. Diseño e Implementación de TADs

3.1 Diseño

TAD TarroTempera
Datos mínimos:
  - codigo, cadena de caracteres, identifica el color de témpera que será almacenado en el tarro.
  - descripcion, cadena de caracteres, representa una lista corta de los componentes usados y su proporción.
  - fecha, cadena de caracteres, identifica el día, mes y año en el que se fabricó el tarro de témpera, separados por /.
  - tiempo, entero, representa la cantidad de minutos utilizados en la fabricación del tarro de témpera.
Operaciones:
  - TarroTempera(), crea un nuevo tarro con los datos vacíos.
  - FijarCodigo(ncod), asigna un nuevo código de color al tarro.
  - FijarDescripcion(ndesc), asigna una nueva descripción de componentes y proporciones al tarro.
  - FijarFecha(nfecha), asigna un nueva fecha de fabricación al tarro.
  - FijarTiempo(ntiemp), asigna un nuevo tiempo de fabricación al tarro.
  - ObtenerCodigo(), retorna el código de color del tarro.
  - ObtenerDescripcion(), retorna la descripción de componentes y proporciones del tarro.
  - ObtenerFecha(), retorna la fecha de fabricación del tarro.
  - ObtenerTiempo(), retorna el tiempo de fabricación del tarro.

TAD ColaColor
Datos mínimos:
  - numero, entero, identifica de forma particular la cola de tarros de témpera.
  - codigo, cadena de caracteres, representa el color de los tarros de témpera almacenados.
  - tarros, cola de TarroTempera, representa los tarros de témpera almacenados en la cola, listos para ser distribuídos en las cajas.
Operaciones:
  - ColaColor(), crea una nueva cola de tarros de témpera con antributos vacíos.
  - FijarNumero(nnum), asigna un nuevo número de cola.
  - FijarCodigo(ncod), asigna un nuevo código de color de los tarros en la cola.
  - FijarTarros(ncol), asigna una nueva cola de tarros de témpera.
  - ObtenerNumero(), retorna el número de cola.
  - ObtenerCodigo(), retorna el código de color de los tarros en la cola.
  - ObtenerTarros(), retorna la cola de tarros de témpera.
  - AgregarTarro(ntarro), agrega un nuevo tarro a la cola.
  - RetirarTarro(), retira un tarro disponible en la cola.

TAD CajaTemperas
Datos mínimos:
  - nombre, cadena de caracteres, nombre que identifica la caja de témperas.
  - cantidad, entero, cantidad de tarros de témpera que contiene la caja.
  - colores, lista de cadena de caracteres, representa los códigos de colores que debe contener la caja.
  - tarros, lista de TarroTempera, representa los tarros de témpera dentro de la caja.
Operaciones:
  - CajaTemperas(), crea una nueva caja de témperas con atributos vacíos.
  - FijarNombre(nnom), asigna un nuevo nombre a la caja de témperas.
  - FijarCantidad(ncant), asigna una nueva cantidad de tarros que contiene la caja.
  - FijarColores(nlista), asigna una nueva lista de colores de tarros.
  - FijarTarros(ntarros), asigna una nueva lista de tarros de témpera.
  - ObtenerNombre(), retorna el nombre de la caja de témperas.
  - ObtenerCantidad(), retorna la cantidad actual de témperas en la caja.
  - ObtenerColores(), retorna la lista de códigos de colores en la caja de témperas.
  - ObtenerTarros(), retorna la lista de tarros de témperas.
  - AgregarTarro(ntarro), incluye un nuevo tarro en la caja de témperas.

TAD MiPintor
Datos mínimos:
  - colasCol, lista de ColaColor, representa el conjunto de colas de tarros de témpera disponibles en la fábrica.
Operaciones:
  - FijarColasCol(nlista), asigna una nueva lista de colas de tarros.
  - ObtenerColasCol(), retorna la lista de colas de tarros actual.
  - ArmarCaja(nombre, tamaño, colores), simula el proceso físico de armado de una caja de tarros de témpera, utilizando el nombre, la cantidad y la lista de los colores requeridos.
  - CalcularTPromedio(), retorna una lista con el tiempo promedio de fabricación de un tarrito para cada uno de los colores disponbles en la fábrica.

3.2 Diagrama de relación entre TADs

3.3 Armar una caja de témperas

// pasos a seguir:
// - Verificar que el tamaño solicitado corresponde con alguno de los tamaños válidos (6, 12 o 24).
// - Verificar que los códigos de colores en la lista representan colores diferentes.
// - Crear una nueva caja de témperas, con el nombre dado, el tamaño requerido, y una nueva lista de tarros de témpera con el tamaño establecido.
// - Recorrer la lista de códigos de colores, por cada código recorrer la lista de colas de tarros.
// - Al encontrar la cola correspondiente, retirar uno de los tarros y ponerlo en la lista de la caja de témperas.
// - Repetir el proceso hasta acabar la lista de códigos, o hasta llegar a una cola que no tenga tarros.

CajaTemperas MiPintor::ArmarCaja( std::string nombre, int cantidad, std::vector<std::string> cods ) {
   CajaTemperas cajaNueva = new CajaTemperas();
   std::list< ColaColor >::iterator cIt;

   // verificar tamaño válido de la caja
   if ( cantidad == cods.size() && (cantidad == 6 || cantidad == 12 || cantidad == 24) ) {
      
      // verificar códigos de color diferentes
      bool rep = false;
      for ( int i = 0; i < cods.size() && !rep; i++ ) {
         short cont = 0;
         
         for ( cIt = colasCol.begin(); cIt != colasCol.end(); cIt++ ) {
            if ( cIt->ObtenerCodigo() == cods[i] )   cont++;
         }
         if ( cont > 1 )   rep = true;
      }

      if ( !rep ) {
         std::vector< TarroTempera > tarritos;
         bool falta = false;

         for ( int i = 0; i < cods.size() && !falta; i++ ) {
            
            for ( cIt = colasCol.begin(); cIt != colasCol.end(); cIt++ ) {
               if ( cIt->ObtenerCodigo() == cods[i] ) {
                  TarroTempera nuevoT = cIt->RetirarTarro();
                  if ( nuevoT.ObtenerCodigo() == 0 ) {
                     falta = true;
                  } else {
                     tarritos.push_back(nuevoT);
                     break;
                  }
               }
            }
         }

         if ( !falta ) {
            cajaNueva.FijarNombre(nombre);
            cajaNueva.FijarCantidad(cantidad);
            cajaNueva.FijarTarros(tarritos);
         }
      }
   } 

   return cajaNueva;
}

TarroTempera ColaColor::RetirarTarro() {
   TarroTempera res = new TarroTempera();
   if ( !tarros.empty() ) {
      res = tarros.front();
      tarros.pop();
   }
   return res;
}


3.3 Calcular el tiempo promedio de fabricación por colores

// pasos a seguir:
// - Recorrer cada una de las colas de tarritos en la lista.
// - Para cada cola, extraer uno a uno los tarros e ir acumulando el tiempo de fabricación de cada uno.
// - Para que los tarros no se pierdan, deben almacenarse en una cola auxiliar, que se utilizará para restituír los elementos.
// - Al terminar de acumular los tiempos por cada cola, dividir por el tamaño de la cola y guardar el resultado en la lista de retorno.

std::vector< unsigned int > MiPintor::CalcularTPromedio() {
   std::vector< unsigned int > proms;
   std::queue< TarroTempera > aux;
   unsigned int Tprom;
   TarroTempera tarrito;
   
   std::list< ColaColor >::iterator cIt;
   for ( cIt = colasCol.begin(); cIt != colasCol.end(); cIt++ ) {
      aux.clear();
      Tprom = 0;
      while ( !cIt->empty() ) {
         tarrito = cIt->front();
         cIt->pop();

         Tprom += tarrito.ObtenerTiempo();
         aux.push(tarrito);
      }
      Tprom /= aux.size();
      *cIt = aux;

      proms.push_back(Tprom);
   }

   return proms;
}
