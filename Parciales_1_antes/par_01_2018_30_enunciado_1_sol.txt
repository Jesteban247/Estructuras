Estructuras de Datos
Primer Parcial

1. Análisis de código

1.1 Cuenta las repeticiones de la palabra hola en varias listas de palabras.
1.2 O(n^2), el primer ciclo se repite n veces, el segundo ciclo se repite n veces también, y el tercer ciclo, que está anidado, se repite dependiendo de la longitud de cada lista, que puede generalizarse a n también.

2. Falso o verdadero

2.1 Falso, las pilas y las colas no pueden recorrerse en busca de un elemento, es necesario extraer los elementos en ese caso.
2.3 Verdadero, la complejidad de la búsqueda binaria O(log_2 n) se repite por cada arreglo en el que se aplica, resultando en O(n log_2 n).

3. Diseño e Implementación de TADs

3.1 Diseño

TAD Asesor
Datos mínimos:
- id, entero largo, número único de identificación personal del asesor.
- estado, cadena de caracteres, representa el estado actual del asesor (ocupado, disponible, fuera-servicio).
- tema, cadena de caracteres, representa el tema que puede atender el asesor (VE, ST, RE).
- atendidos, lista de enteros, registra los turnos atendidos por el asesor hasta el momento.
Operaciones:
- obtenerId(), retorna el número de identificación del asesor.
- obtenerEstado(), retorna el estado actual del asesor.
- obtenerTema(), retorna el tema que atiende el asesor.
- obtenerAtendidos(), retorna la lista de turnos atendidos por el asesor.
- fijarId(n_id), modifica la identificación del asesor.
- fijarEstado(n_estado), modifica el estado actual del asesor.
- fijarTema(n_tema), modifica el tema que atiende el asesor.
- fijarAtendidos(n_turnos), modifica la lista de turnos atendidos por el asesor.
- agregarAtendido(turno), agrega el turno dado a la lista de atendidos.

TAD Usuario
Datos mínimos:
- id, entero largo, número único de identificación personal del usuario.
- prioridad, booleano, indica si el usuario debe tener prioridad en la atención.
- tema, cadena de caracteres, representa el tema sobre el cual el usuario requiere atención (VE, ST, RE).
- turno, entero, representa el turno asignado por el sistema al usuario.
Operaciones:
- obtenerId(), retorna el número de identificación del usuario.
- obtenerPrioridad(), retorna la prioridad del usuario.
- obtenerTema(), retorna el tema de consulta del usuario.
- obtenerTurno(), retorna el turno asignado al usuario.
- fijarId(n_id), modifica la identificación del usuario.
- fijarPrioridad(n_prioridad), modifica la prioridad del usuario.
- fijarTema(n_tema), modifica el tema de consulta del usuario.
- fijarTurno(n_turno), modifica el turno asignado al usuario.

TAD CAU
Datos mínimos:
- asesores, lista de Asesor, representa los asesores asignados al CAU.
- colasAtencion, vector de cola de Usuario, representa los usuarios en espera de ser atendidos por ventas, servicio técnico y reclamos.
- consecutivos, vector de entero, representa el turno consecutivo disponible para cada cola: ventas, servicio técnico y reclamos.
Operaciones:
- obtenerAsesores(), retorna la lista de asesores del CAU.
- obtenerColasAtencion(), retorna las colas de usuarios en espera en el CAU. 
- obtenerConsecutivos(), retorna los turnos consecutivos disponibles para cada cola de usuarios. 
- fijarAsesores(n_asesores), modifica la lista de asesores del CAU.
- fijarColasAtencion(n_colas), modifica las colas de usuarios.
- fijarConsecutivos(n_cons), modifica los turnos consecutivos disponibles para cada cola.
- asignarTurno(id,prioridad,tema), genera un usuario con la información dada, le asigna un turno y lo encola en la cola correspondiente al tema.
- atenderUsuario(), revisa la cola más larga, luego busca un asesor disponible que pueda atender ese tema, retira al usuario de la cola y registra el turno con el asesor.
- conteoAtendidos(), revisa los registros de turnos atendidos de cada asesor y genera el total de usuarios atendidos.


3.2 Asignar un turno

// pasos a seguir:
// - asignar un turno al usuario, de acuerdo al consecutivo registrado para cada tema
// - crear un nuevo usuario para almacenar toda la información
// - insertar ese usuario nuevo en la cola correspondiente al tema de consulta

string CAU::asignarTurno(int id, bool prioridad, string tema) {
    // identificar indice de tema para los vectores
	int act;
	if (tema == "VE")  act = 0;
	else if (tema == "ST")  act = 1;
	else if (tema == "RE")  act = 2;
	else return " ";

    // asignar un turno consecutivo del tema indicado
	int turnoU = consecutivo[act];
	consecutivo[act]++;

    // crear un nuevo usuario con toda la informacion
	Usuario nuevoU;
	nuevoU.fijarId(id);
	nuevoU.fijarPrioridad(prioridad);
	nuevoU.fijarTema(tema);
	nuevoU.fijarTurno(turnoU);

    // de acuerdo a la prioridad, insertar al final de la cola
    // o al principio de la cola (sacando y restituyendo lo que ésta ya tenía)
	if (!prioridad) {
	    colasAtencion[act].push(nuevoU);
	} else {
	    std::queue<Usuario> tempQ;
	    Usuario tempU;
	    while (!colasAtencion[act].empty()) {
            tempU = colasAtencion[act].front();
            colasAtencion[act].pop();
            tempQ.push(tempU);
	    }
	    colasAtencion[act].push(nuevoU);
	    while (!tempQ.empty()) {
            tempU = tempQ.front();
            tempQ.pop();
            colasAtencion[act].push(tempU);
	    }
	}

	return turnoU;
}

3.3 Atender un usuario

// pasos a seguir:
// - revisar las colas de atención, e identificar aquella con mayor cantidad de usuarios
// - revisar los asesores, verificando que esté disponible y que atienda el tema escogido
// - registrar el turno con el asesor y retirar al usuario de la cola

bool CAU::atenderUsuario() {
    bool atendido = false;

    // identificar indice de la cola con mas usuarios
    int tamax = 0;
    int act;
	for (int i = 0; i < 3; i++) {
	    if (colasAtencion[i].size() > tamax) {
            act = i;
            tamax = colasAtencion[i].size();
	    }
	}

    // de acuerdo al indice, identificar el tema de la cola
    string temaU;
	switch (act) {
	    case 0: temaU = "VE"; break;
	    case 1: temaU = "ST"; break;
	    case 2: temaU = "RE"; break;
	}

    // revisar uno a uno los asesores, buscando el primero que atienda el tema
    // identificado y que ademas este disponible
    std::list<Asesor>::iterator itA;
    std::list<Asesor>::iterator itAsesor = asesores.end();
    for (itA = asesores.begin(); itA != asesores.end(); itA++) {
        if (itA->obtenerTema() == temaU && itA->obtenerEstado() == "disponible") {
            itAsesor = itA;
            break;
        }
    }

    // si fue posible encontrar un asesor con ambas caracteristicas
    // entonces retirar al usuario de la cola, agregar el turno al registro
    // del asesor y cambiar el estado actual del asesor
    if (itAsesor != asesores.end()) {
        Usuario esteU = colasAtencion[act].front();
        colasAtencion[act].pop();
        itAsesor->agregarAtendido(esteU.obtenerTurno());
        itAsesor->fijarEstado("ocupado");
        atendido = true;
    }

    return atendido;
}

void Asesor::agregarAtendido(int turno) {
	atendidos.push_back(turno);
}

3.4 Conteo de usuarios atendidos

// pasos a seguir:
// - revisar uno a uno los asesores del CAU, sin importar su estado
// - para cada asesor, extraer el tamaño del registro de turnos
// - sumar todos los tamaños para entregar el total de atendidos

int CAU::conteoAtendidos() {
    int conteo = 0;
    std::list<int> lTurnos;
	std::list<Asesor>::iterator itA;
    for (itA = asesores.begin(); itA != asesores.end(); itA++) {
        lTurnos = itA->obtenerAtendidos();
        conteo += lTurnos.size();
    }
    return conteo;
}