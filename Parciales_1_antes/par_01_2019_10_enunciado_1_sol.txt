Estructuras de Datos
Primer Parcial

1. Análisis de código

1.1 Extrae el dato de la mitad de cada lista de la multilista.
1.2 O(n^2), el primer ciclo se repite n veces, y el segundo ciclo, que está anidado, se repite n/2 veces, que puede generalizarse a n también (porque dependerá de la longitud de la lista).

2. Falso o verdadero

2.1 O(n^2), se hacen hasta n intercambios, y eso se repite n veces hasta lograr el ordenamiento de la secuencia completa.
2.2 son implementaciones en C++ de una secuencia lineal de datos.

3. Diseño e Implementación de TADs

3.1 Diseño

TAD Caja
Datos mínimos:
  - ident, cadena de caracteres, identifica de manera única cada caja (longitud 6, 3 caracteres alfabéticos y 3 números dígitos).
  - material, cadena de caracteres, representa la clase de material del que está hecha la caja.
  - delicada, booleano, identifica si la caja está clasificada como delicada o no por la naturaleza de su contenido.
Operaciones:
  - Caja(), crea una caja con atributos vacíos (cadenas de tamaño 0 y booleano en falso).
  - Caja(id), crea una caja con un identificador dado.
  - FijarId(nid), cambia el valor de la identificación por nid.
  - FijarMaterial(nmat), cambia el valor del material por nmat.
  - FijarDelicada(nbool), cambia el valor del indicador de delicada por nbool.
  - ObtenerId(), retorna el identificador actual de la caja.
  - ObtenerMaterial(), retorna el material actual de la caja.
  - ObtenerDelicada(), retorna el indicador actual de la caja.

TAD PilaCajas
Datos mínimos:
  - ident, cadena de caracteres, identifica de manera única cada pila de cajas.
  - pCajas, pila de Caja, representa las cajas apiladas que se encuentran en un momento dado en la pila de cajas.
  - tamMax, entero, cantidad máxima de cajas que pueden ubicarse en la pila de cajas.
Operaciones:
  - PilaCajas(), crea una pila de cajas con atributos vacíos.
  - PilaCajas(id), crea una pila de cajas con un identificador dado.
  - FijarId(nid), cambia el valor de la identificación por nid.
  - FijarPila(npila), cambia el valor de la pila de cajas por npila.
  - FijarTamMax(ntam), cambia el valor del tamaño máximo por ntam.
  - ObtenerId(), retorna el identificador actual de la pila de cajas.
  - ObtenerPila(), retorna la pila actual de cajas.
  - ObtenerTamMax(), retorna el tamaño máximo actual de la pila de cajas.
  - ObtenerTamano(), retorna la cantidad de cajas que se encuentran actualmente dentro de la pila.
  - AgregarCaja(ncaja), agrega una caja en el tope de la pila actual de cajas.
  - EliminarCaja(), elimina la caja que se encuentre en el tope de la pila actual de cajas.
  - ObtenerCajaTope(), retorna la caja que se encuentra en el tope de la pila.

TAD MiBodeguita
Datos mínimos:
  - lPilas, lista de PilaCajas, representa las pilas de cajas ubicadas en la bodega.
Operaciones:
  - MiBodeguita(), crea una bodega con una lista vacía de cajas.
  - FijarLista(nlista), cambia el valor de la lista de pilas por nlista.
  - ObtenerLista(), retorna la lista actual de pilas de cajas.
  - ConteoCajas(), retorna la cantidad actual de cajas ubicadas dentro de la bodega.
  - Agregar(ncaja,pila), intenta agregar la caja ncaja en la pila identificada por pila. Retorna verdadero si el procedimiento es satisfactorio, falso si no ha sido posible insertar la caja en la pila dada.
  - Buscar(inf,sup), recorre la lista de pilas de cajas y almacena en una estructura lineal todas las cajas cuyo identificador se encuentra en el rango definido por inf y sup.



3.2 Conteo de cajas

// pasos a seguir:
// - recorrer la lista de pilas.
// - para cada pila, sacar su tamaño actual.
// - ir sumando los tamaños en una variable, y luego retornarla.

unsigned long MiBodeguita::ConteoCajas() {
   unsigned long cantidad = 0;
   std::list<PilaCajas>::iterator it;

   for ( it = lPilas.begin( ); it != lPilas.end( ); it++ ) {
      cantidad += it->ObtenerTamano();
   }

   return cantidad;
}

// función que retorna el tamaño actual de la pila
unsigned int PilaCajas::ObtenerTamano () {
  return pCajas.size();
}

3.3 Agregar nueva caja

// pasos a seguir:
// - recorrer la lista de pilas, buscando la pila particular
// - si no se encuentra la pila, retornar falso
// - si se encuentra la pila, verificar el tamaño actual con respecto al tamaño máximo
// - si hay campo, hacer un push de la caja dada en la pila y retornar verdadero
// - si no hay campo, retornar falso

bool MiBodeguita::Agregar(Caja ncaja, std::string pila) {
   bool insertada = false;
   std::list<PilaCajas>::iterator it;

   for ( it = lPilas.begin( ); it != lPilas.end( ); it++ ) {
      if (it->ObtenerId() == pila) {
         if (it->ObtenerTamano() < it->ObtenerTamMax()) {
            it->AgregarCaja(ncaja);
            insertada = true;
         }
      }
   }

   return insertada;
}

// función que agrega la caja a la pila
void PilaCajas::AgregarCaja (Caja ncaja) {
  pCajas.push(ncaja);
}

3.4 Búsqueda de cajas con identificador en un rango

// pasos a seguir:
// - recorrer la lista de pilas
// - para cada pila, ir sacando las cajas, para verificar si su identificador se encuentra dentro del rango especificado
// - en ese caso, la caja debe agregarse a la estructura que se va a retornar como parte de la función, este proceso debe hacerse de manera ordenada 
// - al sacar las cajas de la pila, deben almacenarse en una estructura auxiliar, que permita luego dejar la pila de cajas tal y como estaba
// - al finalizar el recorrido, se retorna la estructura con todas las cajas

std::vector<Caja> MiBodeguita::Buscar (std::string inf, std::string sup) {
   std::list<PilaCajas>::iterator it;
   std::vector<Caja> colaCajas;
   std::vector<Caja>::iterator itc;
   std::stack<Caja> pCajasAct, tempCajas;
   Caja cajaAct;

   // recorrer la lista de pilas
   for ( it = lPilas.begin( ); it != lPilas.end( ); it++ ) {

      // mientras haya cajas en la pila
      while (it->ObtenerTamano() > 0) {

         // extraer la caja, ponerla en una pila temporal
         cajaAct = it->ObtenerCajaTope();
         tempCajas.push(cajaAct);
         it->EliminarCaja();

         // verificar si el identificador de la caja está en el rango
         if (cajaAct.ObtenerId() >= inf && cajaAct.ObtenerId() <= sup) {
    
            // insertar ordenadamente la caja con respecto a su identificador
            for (itc = colaCajas.begin(); itc != colaCajas.end(); itc++) {
               if (itc->ObtenerId() > cajaAct.ObtenerId()) {
                  break;
               }
            }
            if (itc != colaCajas.end()) {	
               colaCajas.insert(itc,cajaAct);
            } else {
               colaCajas.push_back(cajaAct);
            }

         }
      }

      //  cuando termino de sacar todas las cajas de la pila, las regreso a su pila original
      while (!tempCajas.empty()) {
         cajaAct = tempCajas.top();
         it->AgregarCaja(cajaAct);
         tempCajas.pop();
      }
   }

   return colaCajas;
}

// función que retorna la caja que se encuentra en el tope de la pila
Caja PilaCajas::ObtenerCajaTope () {
  return pCajas.top();
}

// función que elimina la caja que se encuentre en el tope de la pila
void PilaCajas::EliminarCaja () {
  pCajas.pop();
}
